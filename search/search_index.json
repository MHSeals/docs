{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-the-official-roboboat-cs-documentation","title":"Welcome to the official Roboboat CS Documentation","text":"<p>This is the home page for the documentation over Computer Science at MHSeals. Here you'll find guides, tutorials, and reference material for robotics, ROS2, hardware, simulation, and more. Use this page as a table of contents if you are looking for something specific and are unsure of where it would be located.</p>"},{"location":"#archive","title":"Archive","text":"<p>Deprecated documentation</p> <ul> <li>KISS-ICP</li> <li>MAVROS</li> <li>SLAM Toolbox</li> </ul>"},{"location":"#hardware","title":"Hardware","text":"<ul> <li>Cube Orange</li> <li>Jetson Xavier NX</li> <li>Network</li> <li>Odroid</li> <li>Overview</li> <li>Velodyne VLP-16</li> <li>Zed 2i</li> </ul>"},{"location":"#setup","title":"Setup","text":"<ul> <li>Installing Ubuntu</li> <li>Workspace Setup</li> </ul>"},{"location":"#sim","title":"Sim","text":"<ul> <li>(...)</li> </ul>"},{"location":"#software","title":"Software","text":"<ul> <li>(...)</li> </ul>"},{"location":"#starting","title":"Starting","text":"<ul> <li>(...)</li> </ul>"},{"location":"#website","title":"Website","text":"<ul> <li>Development</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>Help us improve! Submit a pull request on GitHub to add or update documentation.</p>"},{"location":"archive/kiss-icp/","title":"Kiss icp","text":""},{"location":"archive/kiss-icp/#kiss_icp","title":"kiss_icp","text":"<p>kiss_icp is an odometry pipeline 'that just works'. :3</p>"},{"location":"archive/kiss-icp/#installation","title":"installation","text":"<ol> <li>run <code>pip install kiss-icp</code></li> <li>that's it! you're done!</li> </ol>"},{"location":"archive/kiss-icp/#running-kiss_icp","title":"running kiss_icp","text":"<p>run <code>ros2 launch kiss_icp odometry.launch.py topic:=/wamv/sensors/lidars/lidar_wamv_sensor/points</code></p>"},{"location":"archive/mavros/","title":"Mavros","text":""},{"location":"archive/mavros/#mavros_1","title":"MAVROS","text":""},{"location":"archive/mavros/#setmode","title":"SetMode","text":"<ul> <li>create a <code>mavros_msgs.srv.SetMode</code> client for the <code>/mavros/set_mode</code> topic<ul> <li>Mode options: <code>MANUAL</code>, <code>GUIDED</code>, <code>HOL</code></li> </ul> </li> </ul>"},{"location":"archive/mavros/#thrusters","title":"thrusters","text":"<ul> <li>publish a <code>geometry_msgs.msg.TwistStamped</code> message to the <code>/mavros/setpoint_velocity/cmd_vel</code> to control speed</li> </ul>"},{"location":"archive/mavros/#twiststamped-messages","title":"TwistStamped messages","text":"<p>ie. twist message named 'mymessage': - Linear velocity can be modified with <code>mymessage.twist.linear.[x(forwards)/y(backwards)]</code>     - measured in m/s - Angular velocity (rotating the boat) can be modified with <code>mymessage.twist.angular.z</code>     - mesured in rad/s</p>"},{"location":"archive/slam-toolbox/","title":"Slam toolbox","text":""},{"location":"archive/slam-toolbox/#slam_toolbox","title":"slam_toolbox","text":"<p>slam_toolbox is a package we use to implement the SLAM algorithm in roboboat :)</p> <p>bryan's documentation</p>"},{"location":"archive/slam-toolbox/#what-is-slam","title":"what is slam?","text":"<p>slam stands for Simultaneous Localization and Mapping\u2026 but what does that mean?! * localization: positioning yourself relative to a map without global positioning (like gps) * mapping: exploring surroundings and using the data to form a map * slam = localizing and mapping at the same time!</p>"},{"location":"archive/slam-toolbox/#how-to-use-slam_toolbox","title":"how to use slam_toolbox","text":"<ul> <li>slam_toolbox subscribers to data from <code>/tf</code> and <code>/scan</code></li> <li><code>/odom</code> and <code>/laser</code> topics need to be linked in the <code>/tf</code> tree</li> </ul>"},{"location":"archive/slam-toolbox/#installation","title":"installation","text":"<ol> <li>update your system <code>sudo apt update &amp;&amp; sudo apt upgrade</code></li> <li>install slam_toolbox <code>sudo apt install ros-humble-slam-toolbox</code></li> <li>build your packages <code>colcon build</code></li> </ol> <p>now you can run slam_toolbox with the code below! <code>ros2 launch slam_toolbox online_async_launch.py use_sim_time:=True</code> * this command runs slam_toolbox in online asynchronous mode</p>"},{"location":"archive/slam-toolbox/#configuration","title":"configuration","text":"<p>slam_toolbox comes with template default config files you can copy and modify this code below will copy one of the template files to your current working directory <code>cp /opt/ros/humble/share/slam_toolbox/config/mapper_params_online_async.yaml .</code></p>"},{"location":"archive/slam-toolbox/#rviz-and-slam_toolbox","title":"rviz and slam_toolbox","text":""},{"location":"archive/slam-toolbox/#view-slam_toolbox-data","title":"view slam_toolbox data","text":"<ol> <li>open rviz <code>ros2 launch vrx_gazebo rviz.launch.py</code></li> <li>add a laserscan node</li> <li>profit?</li> </ol>"},{"location":"archive/slam-toolbox/#slam_toolbox-rviz-plugin","title":"slam_toolbox rviz plugin","text":"<ol> <li>open rviz <code>ros2 launch vrx_gazebo rviz.launch.py</code></li> <li>Menu bar (top left corner) -&gt; Panels -&gt; Add New Panel</li> <li>You should now see the SlamToolboxPlugin panel in the list of panels!</li> </ol>"},{"location":"custom-implementation/boat-interfaces/","title":"Boat Interfaces","text":""},{"location":"custom-implementation/boat-interfaces/#custom-ros2-messages-for-mhseals-boat-boat_interfaces","title":"Custom ROS2 Messages for MHSeals Boat (boat_interfaces)","text":"<p>This page documents the <code>boat_interfaces</code> repository, which provides custom ROS2 message definitions essential for the MHSeals boat control system and related packages.</p>"},{"location":"custom-implementation/boat-interfaces/#overview","title":"Overview","text":"<ul> <li>Repository: MHSeals/boat_interfaces</li> <li>Main Language: ROS2 message definition (IDL)</li> <li>Framework: ROS 2 Humble</li> <li>Purpose: Defines custom messages for inter-node communication in MHSeals boat software</li> </ul>"},{"location":"custom-implementation/boat-interfaces/#features-usage","title":"Features &amp; Usage","text":"<ul> <li>Provides all custom message types required by the MHSeals boat control system and related packages (e.g., <code>mhsboat_ctrl</code>, <code>buoy_recognition</code>, etc).</li> <li>Enables structured communication between nodes for sensor data, task status, and control commands.</li> <li>Ensures compatibility and modularity across the MHSeals ROS2 ecosystem.</li> </ul>"},{"location":"custom-implementation/boat-interfaces/#how-to-use","title":"How to Use","text":""},{"location":"custom-implementation/boat-interfaces/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/MHSeals/boat_interfaces.git ~/ros_ws/src/boat_interfaces\n</code></pre>"},{"location":"custom-implementation/boat-interfaces/#2-build-the-messages","title":"2. Build the Messages","text":"<ul> <li>Build your ROS2 workspace to generate message headers: <pre><code>cd ~/ros_ws\ncolcon build --symlink-install --packages-select boat_interfaces\n</code></pre></li> </ul>"},{"location":"custom-implementation/boat-interfaces/#3-add-as-a-dependency","title":"3. Add as a Dependency","text":"<ul> <li>Add <code>boat_interfaces</code> to your package's <code>package.xml</code> and <code>setup.py</code> (if using Python).</li> <li>Import and use the custom messages in your ROS2 nodes.</li> </ul>"},{"location":"custom-implementation/boat-interfaces/#example-messages","title":"Example Messages","text":"<ul> <li>(Refer to the repository for the full list and definitions)</li> <li>Typical messages may include:</li> <li>Sensor data (e.g., processed LiDAR, camera detections)</li> <li>Task status and completion</li> <li>Control commands for actuators</li> </ul>"},{"location":"custom-implementation/boat-interfaces/#integration","title":"Integration","text":"<ul> <li>Required by the MHSeals boat control system (<code>mhsboat_ctrl</code>) and other related packages.</li> <li>Ensures all nodes can communicate using a shared set of message types.</li> </ul>"},{"location":"custom-implementation/boat-interfaces/#references-links","title":"References &amp; Links","text":"<ul> <li>MHSeals/boat_interfaces GitHub</li> <li>ROS 2 Custom Messages Documentation</li> </ul>"},{"location":"custom-implementation/buoy-model/","title":"Buoy Model","text":""},{"location":"custom-implementation/buoy-model/#buoy-detection-model-buoy-model","title":"Buoy Detection Model (buoy-model)","text":"<p>This page documents the MHSeals buoy detection model repository, which is used to train and run object detection models for buoys using YOLOv8 and Roboflow datasets.</p>"},{"location":"custom-implementation/buoy-model/#overview","title":"Overview","text":"<ul> <li>Repository: MHSeals/buoy-model</li> <li>Main Language: Python</li> <li>Framework: YOLOv8 (Ultralytics)</li> <li>Dataset: Roboflow (customizable)</li> </ul>"},{"location":"custom-implementation/buoy-model/#features","title":"Features","text":"<ul> <li>Train custom buoy detection models using annotated datasets</li> <li>Supports Roboflow integration for easy dataset management</li> <li>Multiple run modes: test, detection, and tracking</li> <li>Easily adaptable to other datasets by modifying code</li> </ul>"},{"location":"custom-implementation/buoy-model/#how-to-use","title":"How to Use","text":""},{"location":"custom-implementation/buoy-model/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/MHSeals/buoy-model.git\n</code></pre>"},{"location":"custom-implementation/buoy-model/#2-install-requirements","title":"2. Install Requirements","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"custom-implementation/buoy-model/#3-train-the-model","title":"3. Train the Model","text":"<p><pre><code>python train_annotated.py\n</code></pre> - By default, downloads dataset from Roboflow. - To use your own dataset, modify <code>train_annotated.py</code> to pass your own <code>Dataset</code> instance and remove Roboflow-specific code.</p>"},{"location":"custom-implementation/buoy-model/#4-retrieve-model-weights","title":"4. Retrieve Model Weights","text":"<ul> <li>After training, weights are saved in <code>runs/detect/&lt;version name&gt;/weights/best.pt</code>.</li> <li>Location may vary (project root or Python installation root).</li> </ul>"},{"location":"custom-implementation/buoy-model/#5-run-the-model","title":"5. Run the Model","text":"<ul> <li>Test mode: <pre><code>python detect_test.py\n</code></pre></li> <li>Runs on a folder of images, allows manual navigation.</li> <li>Detection mode: <pre><code>python detect_webcam.py\n</code></pre></li> <li>Runs detection on webcam input.</li> <li>Tracking mode: <pre><code>python detect_tracking.py\n</code></pre></li> <li>Runs object tracking on video input.</li> </ul>"},{"location":"custom-implementation/buoy-model/#roboflow-integration","title":"Roboflow Integration","text":"<ul> <li>Dataset and model management is streamlined with Roboflow.</li> <li>Download Dataset</li> <li>Try Model Online</li> </ul>"},{"location":"custom-implementation/buoy-model/#customization-extending","title":"Customization &amp; Extending","text":"<ul> <li>You can remove Roboflow-specific code to use your own datasets.</li> <li>Modify <code>train_annotated.py</code> and related scripts for custom data pipelines.</li> <li>Supports YOLOv8 features and configuration options.</li> </ul>"},{"location":"custom-implementation/buoy-model/#references-links","title":"References &amp; Links","text":"<ul> <li>MHSeals/buoy-model GitHub</li> <li>YOLOv8 Documentation</li> <li>Roboflow Documentation</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/","title":"Boat Control Package (mhsboat_ctrl)","text":""},{"location":"custom-implementation/mhsboat-ctrl/#mhseals-boat-control-software-mhsboat_ctrl","title":"MHSeals Boat Control Software (mhsboat_ctrl)","text":"<p>This page provides an in-depth overview of the MHSeals boat control software, its architecture, packages, and usage. The control system is designed for modularity, simulation support, and robust autonomous operation using ROS 2.</p> <p>This code is being actively developed and may change frequently so this documentation may not always be up-to-date. Please refer to the GitHub repository for the latest code and updates.</p>"},{"location":"custom-implementation/mhsboat-ctrl/#overview","title":"Overview","text":"<ul> <li>Repository: MHSeals/mhsboat_ctrl</li> <li>Main Language: Python</li> <li>Framework: ROS 2 Humble</li> <li>OS: Ubuntu 22.04</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#architecture-principles","title":"Architecture &amp; Principles","text":""},{"location":"custom-implementation/mhsboat-ctrl/#1-global-coordinates","title":"1. Global Coordinates","text":"<p>All navigation and movement are now referenced to a global coordinate system (e.g., map or GPS coordinates). This allows for easier integration with mapping, localization, and multi-vehicle scenarios.</p>"},{"location":"custom-implementation/mhsboat-ctrl/#2-modularity","title":"2. Modularity","text":"<p>Tasks are implemented as separate classes inheriting from a base <code>Task</code> class. New tasks can be added without affecting existing code.</p>"},{"location":"custom-implementation/mhsboat-ctrl/#3-simulation-support","title":"3. Simulation Support","text":"<p>The system can run in simulation mode using a simulated map, allowing for development and testing without hardware.</p>"},{"location":"custom-implementation/mhsboat-ctrl/#main-packages-their-roles","title":"Main Packages &amp; Their Roles","text":""},{"location":"custom-implementation/mhsboat-ctrl/#mhsboat_ctrl","title":"mhsboat_ctrl","text":"<ul> <li>Purpose: Main control logic, task management, decision-making, actuator interfacing.</li> <li>Key Files:</li> <li><code>mhsboat_ctrl.py</code>: Main loop, task execution, sensor integration.</li> <li><code>task.py</code>: Base class for all tasks.</li> <li><code>tasks/</code>: Individual task implementations (navigation, obstacle avoidance, etc).</li> <li>ROS Topics:</li> <li>Subscribes: <code>/mhsboat_ctrl/map</code></li> <li>Publishes: <code>/mavros/setpoint_velocity/cmd_vel</code></li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#sensors","title":"sensors","text":"<ul> <li>Purpose: Sensor data collection, fusion, and processing (camera, LiDAR, odometry).</li> <li>Key Files:</li> <li><code>sensors.py</code>: Main sensor node.</li> <li><code>utils/lidar.py</code>: LiDAR data utilities.</li> <li>ROS Topics:</li> <li>Subscribes: <code>/AiOutput</code>, <code>/center_of_clusters</code>, <code>/odometry/filtered</code></li> <li>Publishes: <code>/mhsboat_ctrl/map</code>, <code>/mhsboat_ctrl/buoy_clusters</code></li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#simulated_map","title":"simulated_map","text":"<ul> <li>Purpose: Provides a virtual course for simulation and testing.</li> <li>Key Files:</li> <li><code>gui.py</code>: GUI for visualizing the simulated environment.</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#display_map","title":"display_map","text":"<ul> <li>Purpose: Visualizes map data and detected objects.</li> <li>Key Files:</li> <li><code>testgui.py</code>: GUI for map display.</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#buoy_recognition","title":"buoy_recognition","text":"<ul> <li>Purpose: Detects and classifies buoys/objects using camera images and YOLO model.</li> <li>Key Files:</li> <li><code>buoy_recognition.py</code>: Main node for object detection.</li> <li>Parameters:</li> <li><code>headless_mode</code> (default: True): Controls image display.</li> <li>ROS Topics:</li> <li>Subscribes: <code>/image_raw</code></li> <li>Publishes: <code>/AiOutput</code></li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#center_of_clusters","title":"center_of_clusters","text":"<ul> <li>Purpose: Processes LiDAR point clouds to identify clusters (buoys, obstacles).</li> <li>Key Files:</li> <li><code>center_of_clusters.py</code>: Main clustering node.</li> <li>ROS Topics:</li> <li>Subscribes: <code>/velodyne_points</code></li> <li>Publishes: <code>/center_of_clusters</code></li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#bag_recorder","title":"bag_recorder","text":"<ul> <li>Purpose: Records ROS 2 bag files for data logging and analysis.</li> <li>Key Files:</li> <li><code>bag_recorder.py</code>: Main recording node.</li> <li>ROS Topics:</li> <li>Subscribes: <code>/mhsboat_ctrl/map</code></li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#task-system","title":"Task System","text":"<ul> <li>Tasks are stored in <code>mhsboat_ctrl/tasks/</code>.</li> <li>Each task is a class inheriting from <code>Task</code> (in <code>task.py</code>).</li> <li>The base <code>Task</code> class defines <code>run</code> and <code>search</code> methods.</li> <li>To add a new task: create a new file/class in <code>tasks/</code>, inherit from <code>Task</code>, and register with <code>BoatController.add_task</code>.</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#main-loop-execution","title":"Main Loop &amp; Execution","text":"<ul> <li>The main loop (in <code>mhsboat_ctrl.py</code>) continuously searches for and executes tasks.</li> <li>Each task receives a <code>Sensors</code> object for data and map access.</li> <li>Task completion and status are managed using enums (<code>TaskCompletionStatus</code>, <code>TaskStatus</code> in <code>enums.py</code>).</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#simulation-mode","title":"Simulation Mode","text":"<p>This mode does not currently work, it is being worked on.</p> <ul> <li>Run with parameters: <code>use_simulated_map</code> and <code>map_file</code>.</li> <li>Example:   <pre><code>ros2 run mhsboat_ctrl mhsboat_ctrl --ros-args -p use_simulated_map:=true -p map_file:=src/mhsboat_ctrl/maps/taskone.yaml\n</code></pre></li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#building-running","title":"Building &amp; Running","text":"<ul> <li>Build with symlink install for easy code changes:   <pre><code>cd ~/ros_ws\ncolcon build --symlink-install --packages-select mhsboat_ctrl\n</code></pre></li> <li>See commands_to_run_boat.md for run instructions.</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#contributing-extending","title":"Contributing &amp; Extending","text":"<ul> <li>See CONTRIBUTING.md for guidelines.</li> <li>Modular design makes it easy to add new sensors, tasks, or simulation features.</li> </ul>"},{"location":"custom-implementation/mhsboat-ctrl/#references-links","title":"References &amp; Links","text":"<ul> <li>MHSeals/mhsboat_ctrl GitHub</li> <li>Custom messages: boat_interfaces</li> <li>ROS 2 Documentation</li> </ul>"},{"location":"getting-started/basic-terminology/","title":"Basic Terminology","text":"<ul> <li>Linux: An open-source operating system modeled on UNIX.</li> <li>Distro: Short for distribution. Each Linux Distro differs in their package manager, release cadence, user interfaces, and overall philosophical goals. Different versions of ROS may also be referred to as distros.</li> <li>Python: A declarative high-level programming language with abstractions of lower level functionality to allow the programmer to focus on functionality.</li> <li>Declarative: A programming paradigm that focuses on what the desired outcome is, rather than how to achieve it by explicitly detailing step-by-step instructions.</li> <li>Abstraction: The process of simplifying complex systems by hiding unnecessary details and focusing on essential components.</li> <li>Package Manager: A collection of software tools that automates the process of installing, upgrading, configuring, and removing software packages.</li> <li>GUI: Graphical-user interface; the use of visual interactions rather than text-based commands helps minimize the knowledge overhead and provide useful visualizations.</li> <li>Terminal: More formally, a terminal emulator is a graphical application that provides a text-based interface to interact with the shell.</li> <li>Shell: A form of command-line interface that operates through a text-based interface, allowing the user to type commands which the shell interprets then executes by interacting with the underlying operating system.</li> <li>Bash: Bourne Again SHell, or Bash, is the most popular and often default shell in many Linux distributions.</li> <li>Zsh: Z Shell, or Zsh is known for its advanced features like improved tab completion and spell correction along its extensibility by using extensions.</li> <li>ROS: Robot Operating System, or ROS, provides a layer of abstraction that allows developers to write hardware-independent code. This allows the same high-level commands to work across different robot platforms stopping the need to \"reinvent the wheel\" by rewriting existing code. ROS also provides robust tooling for networking information across nodes along with useful simulation and visualization tools. Currently, ROS has two versions, ROS1 and ROS2, each with different iterations such as Jazzy Jalisco or our current distro, Humble Hawkesbill.</li> <li>Robust: Software that is robust consistently performs as expected and is resilient to errors and unexpected conditions.</li> <li>Node: This most atomic portion of a ROS program serving as a modular process that executes a certain function within a robotic system. Nodes are designed to be independent building blocks that communicate through. In Python, nodes are built as classes that can be run directly by using the <code>ros2 run</code> command or an instance can be created through a launch file.</li> <li>Topic: A bus for nodes to exchange messages through asynchronous, unidirectional communication, allowing nodes to publish and subscribe to messages of a specific type. Topics are defined by a path-like structure, starting with a leading slash to be resolved absolutely in a robot (e.g. <code>/odom</code> or <code>/camera/depth/image_rect_raw</code>), or without a leading slash when being used in a namespace with multiple robots (e.g. a swarm of robots each prefixed with <code>/nth_swarm_bot</code> and each with their own <code>camera/depth/image_rect_raw</code>).</li> <li>Message: An object containing data assigned a name and an explicit type (e.g. <code>uint16_t</code> rather than <code>int</code>). ROS messages may not contain multi-dimensional arrays, so they must be flattened into a 1-D representation. Messages may contain data in the form of other message types (e.g. the PointField[] and Header types used in the PointCloud2.msg).</li> <li>Data Type: A classification that specifies the kind of value a variable can hold and a set of functions that can be performed on that value (e.g. int, float, char, bool, string, and user-defined types through classes, and ROS messages).</li> <li>Class: Serves as a blueprint or a template for creating objects. It defines the structure (attributes or properties) and behavior (methods or functions) that objects created from that class will possess.</li> <li>Object: An self-contained instance of a class that has its own attributes.</li> <li>Attributes: Data properties associated with an object representing its current state (e.g. name, age, weight, etc. for a person object). </li> <li>Methods: A function utility or action that an object can perform (e.g. a person object may have walk, talk, and work methods). Often used synonymously with the word \"function.\"</li> <li>Object-Oriented Programming: A programming paradigm that organizes software around objects, promoting concepts such as inheritance and polymorphism to build reusable, modular, and maintainable code.</li> <li>Function: An encapsulated block of code used to improve reusability and abstract logic.</li> <li>Inheritance: A mechanism where a new class (the subclass or child class) acquires the properties and behaviors (fields and methods) of an existing class (the superclass or parent class).</li> <li>Polymorphism: A concept that allows a single interface or method to behave differently based on the object it is acting on or the context it is used in. For instance, in the context of objects, you may have a single shape interface that has a <code>draw()</code> function implemented by a square, triangle, and circle class.</li> <li>Interface: A blueprint or contract that defines a set of methods a class must implement. Interfaces are most commonly used in polymorphism to ensure consistent shared functionality with specialized implementations to account for the nuances of each class.</li> <li>Launch File: A ROS script containing multiple Nodes with parameters to package together needed components to accomplish a shared goal. Launch files are generally used to launch multiple nodes for a robot and end with the <code>.launch.py</code> file extension. </li> <li>Package: Bundles together nodes, libraries, datasets, configuration files, and other resources to accomplish a specific task. Packages are built by using <code>colcon build</code> in the <code>src</code> directory and sourced by running <code>source install/setup.sh</code>. </li> <li>SLAM: Simultaneous localization and mapping; the computational problem of building a map of an unknown environment while simultaneously keeping track of the robot's location within it.</li> <li>Navigation Stack: A collection of ROS packages for robot navigation. It allows a robot to navigate from a starting point to a goal while avoiding obstacles.</li> <li>Gazebo: A piece of simulation software aimed at emulating sensor inputs from a real-world environment. These sensors publish to known topics on the network and can be used to test the logical component of robot code.</li> <li>Feedback: A method used for improving control of machines. It involves measuring a certain parameter (e.g. the position of a robot), comparing it to a desired value, and based on the discrepancy, making a correction (turning or accelerating/decelerating the robot). This process repeats continually and is known as feedback loop.</li> <li>IMU: Inertial measurement unit: A sensor system that typically combines accelerometers, gyroscopes, and electronic compasses. It measures orientation, velocity, and inertial forces.</li> <li>LIDAR: Light detection and ranging. A LIDAR system (or laser range finder) sends out beams of light and measures the time that the beam takes to bounce off of an object and return to the sensor. This gives the distance from the sensor to the object, generating a 3-D point cloud of the surrounding environment.</li> <li>PID: Proportional integral derivative controller; uses three tuned gains to correct a given parameter with closed-loop control to account for real-world error. The proportional gain is directly proportional to the error (e.g. distance from a desired goal) and nears 0 the lower the error. The integral gain incrementally increases by the current error over time, accumulating to account for the time spent with error. The derivative gain aims to dampen overshooting caused by the integral gain by fighting against suddent changes in error.</li> <li>Computer Vision: A specialized type of neural network that teaches computers to interpret camera input to accomplish things such as detecting visible objects in the frame.</li> <li>YOLO: You Only Look Once; a computer vision object-detection framework that simplifies the process of employing an object-detection model.</li> <li>GitHub: A cloud platform for handling Git repositories with various project management tools. It acts as a way to host our code and collaborate as a team.</li> <li>Git: A version management tool that tracks changes to a repository, enabling simpler identification of breaking changes and code sharing.</li> <li>OpenCV: An image processing tool used to handle and manipulate raw images for improved object-detection accuracy and image manipulation.</li> <li>NumPy: A Python library with fast, vectorized mathematical functions implemented under the hood with C++ for better performance optimization.</li> <li>Library: A collection of reusable code bundled in a downloadable package with related functionalities placed in a single organized unit (e.g. NumPy, OpenCV, and YOLO). </li> <li>Nav2: A ROS navigation package with modular extensions abstracting common navigation algorithms used in robotics such as path-planning, path following, position correction, object avoidance, etc.</li> <li>Motor Controller: A device used to translate rotational and speed inputs from a separate controller into electric pulses with the a stable voltage and current to control a motor.</li> <li>PWM: Pulse-width modulation; a technique for controlling the average power delivered to a device by rapidly switching the power on and off commonly used to encode analog input or control motor speeds.</li> <li>NVIDIA Jetson Xavier: A computer board with components such as serial ports (USB) and a GPU to run computationally expensive processes. Needed to run the ROS code locally on the boat.</li> <li>Cube Orange: A module containing an IMU, GPIO ports to communicate with motors, and connection to MAVROS, a software used for GPS-based navigation and teleoperated control.</li> <li>RTK: Real-time kinematic; a high-precision satellite-based navigation technique that achieves centimeter-level accuracy by comparing signals from a fixed base station to a mobile rover to correct for GPS signal errors in real-time.</li> <li>Ubuntu: A Debian-based Linux operating system that uses the <code>apt</code> package manager and provides a user-friendly user interface and prepackaged functionality.</li> <li>Arch: A lightweight and flexible Linux distro that takes a \"do it yourself\" approach to everything. All higher-level funtionality including display management, terminals, audio management, network management, bluetooth connections, wallpaper management, etc. must be installed and configured by the user; however, this comes with significant performance, knowledge, and customizability benefits. NOT FOR BEGINNERS. </li> <li>IDE: Integrated development environment; a software application that combines essential developer tools for writing, testing, and debugging code into a single GUI.</li> <li>VSCode: A (somewhat) lightweight IDE that includes support for extensions and has a high degree of customizability.</li> <li>Neovim: An improved version of Vim, a lightweight, portable text editing language/editor that recognizes that most developers spend their time reading and editing code. Neovim offers lua-based extensions and can be customized to fit your exact desires. Vim keybindings can take time to learn, but are highly rewarding, saving significant time while navigating and editing code when used correctly.</li> <li>Docker: A platform that uses operating-system-level virtualization to deliver software in packages called containers. These containers are isolated, self-contained units that bundle an application and all its dependencies, including code, runtime, system tools, system libraries, and settings.</li> </ul>"},{"location":"getting-started/how-to-read/","title":"How To Read","text":""},{"location":"getting-started/how-to-read/#how-to-read-ros-documentation","title":"How to Read ROS Documentation","text":"<p>Understanding ROS documentation is key to working efficiently with robotics software. Here are some tips and examples to help you get started:</p>"},{"location":"getting-started/how-to-read/#reading-topics-and-messages","title":"Reading Topics and Messages","text":"<ul> <li>ROS nodes communicate using messages sent over topics. Each topic has a specific message type, which defines the data structure.</li> <li>Message types are defined using a simple, language-agnostic syntax. They can include integers, floats, arrays, and more.</li> <li>To understand a topic, look up its message type in the documentation. For example:</li> <li>sensor_msgs/PointField message</li> </ul>"},{"location":"getting-started/how-to-read/#how-to-interpret-message-definitions","title":"How to Interpret Message Definitions","text":"<ul> <li>Each message page lists the fields, their types, and descriptions.</li> <li>Example fields: <code>int32</code>, <code>float64</code>, <code>string</code>, <code>array</code>.</li> <li>Messages can be nested (contain other message types).</li> </ul>"},{"location":"getting-started/how-to-read/#reading-api-documentation","title":"Reading API Documentation","text":"<ul> <li>ROS documentation often includes Python and C++ API references for each package.</li> <li>Look for usage examples, function signatures, and parameter descriptions.</li> <li>The docs.ros.org site is the main hub for official documentation.</li> </ul>"},{"location":"getting-started/how-to-read/#tips-for-beginners","title":"Tips for Beginners","text":"<ul> <li>Start with tutorials and overview pages before diving into API details.</li> <li>Use example code to see how messages and topics are used in practice.</li> <li>If you\u2019re stuck, search for guides, blog posts, or video tutorials (e.g., YouTube: \"All you need to know about ROS Messages\").</li> </ul> <p>If you find something confusing, help improve the docs by submitting a pull request!</p>"},{"location":"getting-started/python/","title":"Python","text":"<p>Note</p> <p>This Python guide is actively being expanded as we continue to talk about more concepts. If you would like anything added or have questions, be sure to let one of the CS leads know.</p>"},{"location":"getting-started/python/#resources","title":"Resources","text":"<ul> <li>Learn Python 3 (CodeAcademy)</li> <li>Introductory Python</li> </ul>"},{"location":"getting-started/ros2/","title":"ROS2","text":""},{"location":"getting-started/ros2/#ros-2-overview","title":"ROS 2 Overview","text":"<p>Welcome to ROS 2! ROS (Robot Operating System), is not actually an operating system, but is a powerful set of libraries and tools for building robot software. ROS 2 is the modern, improved version of ROS 1, and our team uses the Humble distribution (as of October 2024).</p>"},{"location":"getting-started/ros2/#what-is-ros-2","title":"What is ROS 2?","text":"<p>ROS 2 helps you create modular, scalable, and robust robotics applications. It provides a flexible framework for writing robot code, connecting sensors, actuators, and algorithms.</p>"},{"location":"getting-started/ros2/#how-does-ros-2-work","title":"How Does ROS 2 Work?","text":"<p> ROS 2 applications are built from interconnected nodes that communicate with each other.</p>"},{"location":"getting-started/ros2/#nodes","title":"Nodes","text":"<p>A node is an executable program that performs a specific task. Nodes can communicate using topics, services, and actions. - Learn more about nodes</p>"},{"location":"getting-started/ros2/#topics-publishers-and-subscribers","title":"Topics, Publishers, and Subscribers","text":"<ul> <li>A publisher sends messages to a topic.</li> <li>Subscribers listen for messages on topics.</li> <li>You can create as many topics as you need!</li> <li>Topics tutorial</li> </ul>"},{"location":"getting-started/ros2/#services-servers-and-clients","title":"Services, Servers, and Clients","text":"<ul> <li>A service client sends a request to a server, which returns a response.</li> <li>Services tutorial</li> </ul>"},{"location":"getting-started/ros2/#actions","title":"Actions","text":"<p> Actions allow for long-running tasks with feedback. They have three parts: 1. Goal 2. Feedback 3. Result - Actions tutorial</p>"},{"location":"getting-started/ros2/#packages","title":"Packages","text":"<p>A package is a collection of code, launch files, and configuration for a specific functionality. To build or update all packages, run:</p> <pre><code>colcon build\n</code></pre> <p>This creates <code>build</code>, <code>install</code>, and <code>log</code> folders in your workspace.</p>"},{"location":"getting-started/ros2/#next-steps","title":"Next Steps","text":"<ul> <li>Ready to start programming? Explore our [Basic Commands][basic-commands] and Workspace Setup guides.</li> <li>Want to help improve these docs? Submit a pull request on GitHub!</li> </ul>"},{"location":"hardware/cube-orange/","title":"Cube Orange","text":""},{"location":"hardware/cube-orange/#cube-orange_1","title":"Cube Orange","text":"<p>The Cube Orange is a flight controller used in the RoboBoat project. It is slowly being phased out of use, we are only using it for IMU and motor outputs at this point.</p>"},{"location":"hardware/jetson-xavier-nx/","title":"Jetson Xavier NX","text":""},{"location":"hardware/jetson-xavier-nx/#nvidia-jetson-xavier-nx","title":"NVIDIA Jetson Xavier NX","text":"<p>The Jetson Xavier NX is used to run the heavy tasks like machine learning.</p>"},{"location":"hardware/network/","title":"Network","text":""},{"location":"hardware/network/#roboboat-network-setup","title":"Roboboat Network Setup","text":"<p>The Roboboat uses a dedicated onboard network for reliable communication and control.</p>"},{"location":"hardware/network/#hardware-overview","title":"Hardware Overview","text":"<ul> <li>Onboard Router: Manages the boat's internal network.</li> <li>Ubiquiti Bullet: Provides WiFi connectivity for the boat.</li> <li>Ubiquiti Rocket: Handles WiFi on the land side (shore station).</li> <li>Wired Connections: All onboard computers are connected via Ethernet for maximum reliability.</li> </ul>"},{"location":"hardware/network/#how-to-connect","title":"How to Connect","text":"<ol> <li>Connect your computer to the onboard router using an Ethernet cable.</li> <li>Ensure your network settings are set to DHCP (automatic IP assignment).</li> <li>For wireless access, connect to the Rocket.</li> </ol>"},{"location":"hardware/network/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer wired connections for all mission-critical systems.</li> <li>Use WiFi only for monitoring or remote access when necessary.</li> <li>Label cables and ports for easy troubleshooting.</li> </ul>"},{"location":"hardware/network/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you can't connect, check cable connections and router power.</li> <li>Make sure your computer's network adapter is enabled and set to DHCP.</li> <li>For WiFi issues, verify the Ubiquiti devices are powered and broadcasting.</li> </ul>"},{"location":"hardware/odroid/","title":"Odroid","text":""},{"location":"hardware/odroid/#odroid_1","title":"Odroid","text":"<p>The Odroid is a secondary processing unit that runs on the boat alongside the Jetson Xavier NX. It is used for additional processing tasks, such as running ROS2 nodes that do not require high GPU performance.</p>"},{"location":"hardware/overview/","title":"Overview","text":""},{"location":"hardware/overview/#roboboat-hardware-overview","title":"Roboboat Hardware Overview","text":"<p>This page provides a summary of the main hardware components used in the Roboboat project. For detailed setup and usage instructions, see the linked documentation for each device.</p>"},{"location":"hardware/overview/#main-components","title":"Main Components","text":"<ul> <li> <p>NVIDIA Jetson Xavier NX     High-performance onboard computer for AI, vision, and ROS2 nodes.</p> <p>[Read more \u2192][jetson-xavier]</p> </li> <li> <p>Odroid     Secondary processing unit for additional ROS2 nodes that do not require high GPU performance.</p> <p>Read more \u2192</p> </li> <li> <p>Cube Orange     Flight controller used for IMU and motor outputs.</p> <p>Read more \u2192</p> </li> <li> <p>VLP-16 LIDAR     3D laser scanner for mapping and obstacle detection.  </p> <p>Read more \u2192</p> </li> <li> <p>Onboard Network     Managed by a router, with Ubiquiti Bullet (boat WiFi) and Rocket (shore WiFi).  </p> <p>Read more \u2192</p> </li> </ul>"},{"location":"hardware/overview/#notes","title":"Notes","text":"<ul> <li>All mission-critical computers are hardwired to the onboard network for reliability.</li> <li>Hardware may change over time; check individual pages for up-to-date info.</li> </ul>"},{"location":"hardware/vlp16/","title":"VLP16","text":""},{"location":"hardware/vlp16/#velodyne-vlp-16-lidar","title":"Velodyne VLP-16 (LIDAR)","text":"<p>The VLP-16 is a 3D LIDAR sensor used for robotics and mapping. Note: The VLP-16 will be unused for Roboboat projects from 2026 onward.</p>"},{"location":"hardware/vlp16/#hardware-setup","title":"Hardware Setup","text":"<ol> <li>Power the LIDAR using the included adapter.</li> <li>Connect the LIDAR to your computer via Ethernet.</li> <li>Make sure your computer's Ethernet port is configured to communicate with the sensor (check your network settings).</li> </ol>"},{"location":"hardware/vlp16/#ros-integration","title":"ROS Integration","text":"<ul> <li>Install the official velodyne ROS driver or use community packages like <code>velodyne_ros_tools</code>.</li> <li>The VLP-16 publishes <code>sensor_msgs/msg/PointCloud2</code> messages, typically to <code>/wamv/sensors/lidars/lidar_wamv_sensor/points</code> or <code>/velodyne_points</code>.</li> <li>To view data, use RViz and add a PointCloud2 display.</li> </ul>"},{"location":"hardware/vlp16/#pointcloud2-message-structure","title":"PointCloud2 Message Structure","text":"<p>Relevant fields: - point_step: Number of bytes per point (<code>uint32</code>) - row_step: Number of bytes per row (<code>uint32</code>)   - Calculated as (# of points in a row \u00d7 point_step) - fields[]: Array describing each attribute in a point (see PointField)</p> <p>Example: <pre><code>mypointcloud.fields = [\n    PointField('x', 0, PointField.FLOAT32, 1),\n    PointField('y', 4, PointField.FLOAT32, 1),\n    PointField('z', 8, PointField.FLOAT32, 1),\n    PointField('intensity', 12, PointField.FLOAT32, 1)\n]\n</code></pre> - attribute: Name (e.g., x, y, z, intensity) - offset: Start index in the point structure - datatype: Data type (e.g., FLOAT32) - count: Number of elements</p>"},{"location":"hardware/vlp16/#troubleshooting-tips","title":"Troubleshooting &amp; Tips","text":"<ul> <li>If you don't see data in RViz, check your Ethernet connection and ensure the driver is running.<ul> <li>Make sure the IP and port configuration in the Velodyne's configuration web interface are correct.</li> </ul> </li> <li>For ROS2 Humble, you may need to convert or adapt drivers/packages.</li> <li>Refer to the VLP-16 User Manual for hardware details.</li> </ul>"},{"location":"hardware/zed-2i/","title":"Zed 2I","text":""},{"location":"hardware/zed-2i/#zed-2i_1","title":"Zed 2i","text":"<p>The Zed 2i is a new camera replacing our outdated Realsense cameras. It is designed to work outside and provides high-resolution stereo vision for depth perception and 3D mapping. It also runs our computer vision model, providing real-time 3d bounding boxes for objects in the camera's field of view.</p>"},{"location":"hardware/zed-2i/#installing-zed-sdk","title":"Installing Zed SDK","text":"<p>https://www.stereolabs.com/docs/installation/linux</p>"},{"location":"setup/installing-ubuntu/","title":"Installing Ubuntu","text":""},{"location":"setup/installing-ubuntu/#installing-ubuntu-2204","title":"Installing Ubuntu 22.04","text":"<p>This guide will help you safely install Ubuntu 22.04 on your laptop for robotics development.</p>"},{"location":"setup/installing-ubuntu/#prerequisites","title":"Prerequisites","text":"<p>You will need:</p> <ul> <li>USB drive (at least 8GB)<ul> <li>If you don't have a USB, ask Alec, Ryan, or Tuyet.</li> </ul> </li> <li>Laptop with:<ul> <li>At least 16GB RAM</li> <li>A USB port</li> </ul> </li> </ul>"},{"location":"setup/installing-ubuntu/#installation-steps","title":"Installation Steps","text":"<ol> <li>Prepare the USB Drive<ul> <li>Download Ventoy and install it on your USB drive.<ul> <li>Linux: Extract the <code>.tar.gz</code> and run <code>tar -xvf &lt;filename&gt;.tar.gz</code>.</li> <li>Windows: Extract the <code>.zip</code> file and run the installer.</li> </ul> </li> </ul> </li> <li>Download Ubuntu<ul> <li>Get the desktop ISO for Ubuntu 22.04.</li> </ul> </li> <li>Copy the ISO<ul> <li>Move the downloaded <code>.iso</code> file to your Ventoy USB drive.</li> </ul> </li> <li>BIOS Setup<ul> <li>Restart your laptop and enter BIOS (try F10, F11, or F12 during boot).</li> <li>Disable Secure Boot (usually in the Boot or Security menu).</li> </ul> </li> <li>Boot from USB<ul> <li>Select your USB drive as the boot device.</li> <li>In Ventoy, choose the Ubuntu ISO to start installation.</li> </ul> </li> <li>Install Ubuntu<ul> <li>Follow the on-screen instructions. Do not turn off your laptop during installation!</li> </ul> </li> <li>Post-Install<ul> <li>After installation, reboot and re-enable Secure Boot in BIOS if needed.</li> </ul> </li> </ol>"},{"location":"setup/installing-ubuntu/#partitioning-tips","title":"Partitioning Tips","text":"<ul> <li>If you want to completely replace Windows, select \"Erase disk and install Ubuntu\" during setup. Ubuntu will handle partitioning automatically.</li> <li>For dual-boot setups, choose \"Install Ubuntu alongside Windows\" and follow the prompts.</li> </ul>"},{"location":"setup/installing-ubuntu/#troubleshooting-safety","title":"Troubleshooting &amp; Safety","text":"<ul> <li>Backup your data before starting! Installing Ubuntu will erase your hard drive if you choose the wipe option.</li> <li>If you get stuck, check the official Ubuntu installation guide or ask a team member for help.</li> </ul>"},{"location":"setup/workspace-setup/","title":"Workspace Setup","text":""},{"location":"setup/workspace-setup/#roboboat-workspace-setup","title":"Roboboat Workspace Setup","text":"<p>Set up your ROS2 development workspace on Ubuntu for Roboboat projects.</p>"},{"location":"setup/workspace-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ubuntu 22.04 (installation guide) Do not use WSL! It will not work!</li> <li>8GB RAM (minimum)</li> </ul>"},{"location":"setup/workspace-setup/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"setup/workspace-setup/#1-install-ros2","title":"1. Install ROS2","text":"<p>Follow the official instructions for ROS2 Humble.</p>"},{"location":"setup/workspace-setup/#2-create-your-workspace","title":"2. Create Your Workspace","text":"<p>Open a terminal and run: <pre><code>mkdir -p ~/roboboat_ws/src\ncd ~/roboboat_ws\n</code></pre></p>"},{"location":"setup/workspace-setup/#3-clone-required-packages","title":"3. Clone Required Packages","text":"<p>Inside the <code>src</code> folder, clone the main control package and interfaces: <pre><code>cd src\ngit clone https://github.com/MHSeals/mhsboat_ctrl\ngit clone https://github.com/MHSeals/boat_interfaces\n</code></pre></p>"},{"location":"setup/workspace-setup/#4-build-the-workspace","title":"4. Build the Workspace","text":"<p>Return to the workspace root and build: <pre><code>cd ~/roboboat_ws\ncolcon build --symlink-install\n</code></pre></p>"},{"location":"setup/workspace-setup/#5-source-the-workspace","title":"5. Source the Workspace","text":"<p>After building, run: <pre><code>source install/setup.bash\n</code></pre></p> <p>Edit your <code>.bashrc</code> and add the following line to source automatically: <pre><code>source ~/roboboat_ws/install/setup.bash\n</code></pre></p>"},{"location":"setup/workspace-setup/#workspace-structure-example","title":"Workspace Structure Example","text":"<p>Your workspace should look like this: <pre><code>roboboat_ws/\n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 install/\n\u251c\u2500\u2500 log/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 mhsboat_ctrl/\n    \u2514\u2500\u2500 boat_interfaces/\n</code></pre></p>"},{"location":"setup/workspace-setup/#tips-troubleshooting","title":"Tips &amp; Troubleshooting","text":"<ul> <li>If you see build errors, check that all ROS2 dependencies are installed.</li> <li>Always run <code>source install/setup.bash</code> in each new terminal before using ROS2 commands. (You can add this to your <code>.bashrc</code> to automate it.)</li> <li>To add more packages, clone them into <code>src</code> and rebuild with <code>colcon build</code>.</li> <li>For help, see the ROS2 documentation or ask a team member.</li> </ul>"},{"location":"simulation/gazebo/","title":"Gazebo","text":""},{"location":"simulation/gazebo/#gazebo_1","title":"gazebo","text":"<p>gazebo is a simulation program we use to test our boat! instead of taking out our boat every time we need to test code, we simply run gazebo! * at the time of writing (2024), we are using Gazebo Garden. this should come preinstalled with the docker installation</p>"},{"location":"simulation/gazebo/#how-to-use-gazebo","title":"how to use gazebo","text":"<p>launch gazebo using the command below: <code>ros2 launch vrx_gz competition.launch.py world:=sydney_regatta</code> once you open up gazebo, you'll probably be greeting with a frozen screen. don't worry, this is normal. give it a minute of two :]</p>"},{"location":"simulation/gazebo/#navigating-gazebo","title":"navigating gazebo","text":""},{"location":"simulation/gazebo/#toolbar","title":"toolbar","text":""},{"location":"simulation/gazebo/#main-view","title":"main view","text":""},{"location":"simulation/gazebo/#panels","title":"panels","text":"<ol> <li>click the 3 buttons on the top right corner</li> <li>type out the panel you want to add</li> <li>profit?</li> </ol>"},{"location":"simulation/tf2/","title":"TF2","text":""},{"location":"simulation/tf2/#tf2_1","title":"tf2","text":"<p>TF2 = TransForm 2</p>"},{"location":"simulation/tf2/#links","title":"links","text":"<p>links =  parts of a robot (ie. Lidar, wheels, thrusters, and camera) links are joined together by joints</p>"},{"location":"simulation/tf2/#view-links-of-a-robot","title":"view links of a robot:","text":"<ol> <li>Open Rviz</li> <li>Select the robot from the left panel</li> <li>expand the \"links\" tab</li> </ol>"},{"location":"simulation/tf2/#positions-and-rotations","title":"positions and rotations","text":"<p>base_link is the origin of a robot, and all other parts of the robot are positioned relative to base_link (it is similar to classes and subclasses) arrows show hierarchy of the tree: the arrow points toward the parent - Red = X axis - Green = Y axis - Blue = Z axis </p>"},{"location":"simulation/tf2/#the-tf-topic","title":"the /tf topic","text":""},{"location":"simulation/tf2/#tf2-tools","title":"tf2-tools","text":"<ul> <li>install via <code>sudo apt install ros-humble-tf2-tools</code></li> </ul>"},{"location":"simulation/tf2/#viewing-data","title":"viewing data","text":"<p><code>ros2 run tf2_tools view_frames</code> creates 2 files: PDF and URDF file PDF gives visual description of the tf2 'tree'</p>"},{"location":"simulation/urdf/","title":"URDF","text":"<p>URDF = Unified Robot Description Format - used to generate TFs</p>"},{"location":"simulation/urdf/#making-a-urdf-file","title":"making a urdf file","text":"<p>urdf files end with .urdf and are in XML format <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"myrobot\"&gt; \n    &lt;!-- your links and joints go here! --&gt;\n&lt;/robot&gt;\n</code></pre></p>"},{"location":"simulation/urdf/#link","title":"link","text":"<p><pre><code>&lt;link name=\"base_link\"&gt;\n    &lt;visual&gt; &lt;!-- physical properties --&gt;\n        &lt;geometry&gt;\n            &lt;box size=\".2 .4 .6\"/&gt; &lt;!-- in meters --&gt;\n        &lt;/geometry&gt;\n        &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\"/&gt;\n        &lt;material name=\"orange\"&gt;\n    &lt;/visual&gt;\n&lt;/link&gt;\n</code></pre> - visual = visual propertries of a link     - you will need to include a geometry tag to create shapes         - box size property: measured in meters, size in XYZ         - material name property: defines color     - origin: defines the offset of the visual (geometry)         - use joints to move a link relative to another instead         - XYZ - determines position         - RPY = Roll (X axis), Pitch (Y axis), Yaw (Z axis) - determines rotation</p>"},{"location":"simulation/urdf/#joint","title":"joint","text":"<p><pre><code>&lt;joint name=\"my_cool_joint\" type=\"fixed\"&gt;\n    &lt;parent link=\"mom\"/&gt;\n    &lt;child link=\"son\"/&gt;\n    &lt;origin xyz=\"0 0 0.5\" rpy=\"0 0 0\"/&gt;\n&lt;/joint&gt;\n</code></pre> * join property type: * the origin tag here represents the child's offset relative to the parent</p>"},{"location":"website/website-documentation/","title":"Development","text":""},{"location":"website/website-documentation/#mhs-seals-website-documentation","title":"MHS Seals Website Documentation","text":"<p>Author: Alec Jensen</p> <p>The website is available at mhsroboboat.com.</p>"},{"location":"website/website-documentation/#local-development","title":"Local Development","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/MHSeals/website2025.git\ncd website2025\n</code></pre></p> </li> <li> <p>Install dependencies: <pre><code>npm install\n</code></pre></p> </li> <li> <p>Start the development server: <pre><code>npm run dev\n</code></pre></p> </li> <li> <p>Open your browser and navigate to <code>http://localhost:4321</code> to view the site.</p> </li> </ol>"},{"location":"website/website-documentation/#pushing-changes","title":"Pushing Changes","text":"<p>The website is (as of me writing this) hosted on Cloudflare Pages (on my account, I need to move it to the organization's account), which automatically deploys changes pushed to the <code>main</code> branch of this repository. Because of this, the main branch is protected and requires pull requests to be merged. So you must either fork the repository or create a branch to make changes.</p> <ol> <li> <p>Create a new branch: <pre><code>git checkout -b my-feature-branch\n</code></pre></p> </li> <li> <p>Make your changes and commit them: <pre><code>git add .\ngit commit -m \"Description of my changes\"\n</code></pre></p> </li> <li> <p>Push your branch to the remote repository: <pre><code>git push origin my-feature-branch\n</code></pre></p> </li> <li> <p>Open a pull request on GitHub to merge your changes into the <code>main</code> branch.</p> </li> <li>Once the pull request is approved and merged, your changes will be automatically deployed to the live site.</li> </ol>"},{"location":"website/website-documentation/#previous-year-pages","title":"Previous Year Pages","text":"<p>The website contains pages for previous years, so you can go back and look at the history of the team. These previous year pages are separate deployments on Cloudflare Pages, and are based on specific branches in this repository. The branches are named <code>2025</code>, <code>2025</code>, etc., and the deployments are available at 2025.mhsroboboat.com, 2024.mhsroboboat.com, etc.</p>"},{"location":"website/website-documentation/#adding-a-new-year-page-to-the-website","title":"Adding a New Year Page to the Website","text":"<ol> <li>In GitHub, after competition season ends, create a new branch for the next year, e.g., <code>2025</code>.</li> <li>In Cloudflare Pages, create a new application<ol> <li>Select <code>Import a repository</code></li> <li>Select the repository <code>MHSeals/website2025</code></li> <li>Go to the application settings</li> <li>Set the production branch to the new branch you created, e.g., <code>2025</code></li> </ol> </li> <li>Make sure the DNS is set up correctly for the new year page (Cloudflare Pages should handle this automatically).</li> <li>Navigate to <code>src\\pages\\year\\[year].astro</code></li> <li>Find <code>export function getStaticPaths()</code></li> <li>Add an object to the return, like this: <code>{ params: { year: \"2025\" }},</code>    replacing <code>2025</code> with the year you want to add.</li> </ol> <p>Example: <pre><code>export function getStaticPaths() {\n   return [\n         { params: { year: \"2025\" }},\n         { params: { year: \"2024\" }},\n         // Add more years as needed\n   ];\n}\n</code></pre> 7. Follow the steps in the \"Pushing Changes\" section to create a pull request and deploy the changes.</p>"}]}